From 2e245efbd1e013295d248614d20a377a51e07512 Mon Sep 17 00:00:00 2001
From: xc-racer99 <xc-racer2@live.ca>
Date: Mon, 23 Apr 2018 19:04:22 -0700
Subject: [PATCH 1/8] Check for pending requests when aseq is invalid for power

Some devices don't properly retain aseq for power commands, so we need to look this up manually
---
 power.c | 18 ++++++++++++++----
 1 file changed, 14 insertions(+), 4 deletions(-)

diff --git a/power.c b/power.c
index 6de7eb0..3198c3e 100644
--- a/power.c
+++ b/power.c
@@ -43,12 +43,22 @@ int ipc_pwr_phone_reset(struct ipc_message *message)
 int ipc_pwr_phone_state(struct ipc_message *message)
 {
 	struct ipc_pwr_phone_state_response_data *data;
+	struct ril_request *request;
+	RIL_Token token;
 
 	if (message == NULL || message->data == NULL || message->size < sizeof(struct ipc_pwr_phone_state_response_data))
 		return -1;
 
-	if (!ipc_seq_valid(message->aseq))
-		return 0;
+	if (!ipc_seq_valid(message->aseq)) {
+		// Some devices don't properly set the aseq here
+		request = ril_request_find_request_status(RIL_REQUEST_RADIO_POWER, RIL_REQUEST_HANDLED);
+		if (request == NULL || request->token == NULL)
+			return 0;
+		else
+			token = request->token;
+	} else {
+		token = ipc_fmt_request_token(message->aseq);
+	}
 
 	data = (struct ipc_pwr_phone_state_response_data *) message->data;
 
@@ -56,13 +66,13 @@ int ipc_pwr_phone_state(struct ipc_message *message)
 		case IPC_PWR_PHONE_STATE_RESPONSE_LPM:
 			RIL_LOGD("Power state is low power mode");
 
-			ril_request_complete(ipc_fmt_request_token(message->aseq), RIL_E_SUCCESS, NULL, 0);
+			ril_request_complete(token, RIL_E_SUCCESS, NULL, 0);
 			ril_radio_state_update(RADIO_STATE_OFF);
 			break;
 		case IPC_PWR_PHONE_STATE_RESPONSE_NORMAL:
 			RIL_LOGD("Power state is normal");
 
-			ril_request_complete(ipc_fmt_request_token(message->aseq), RIL_E_SUCCESS, NULL, 0);
+			ril_request_complete(token, RIL_E_SUCCESS, NULL, 0);
 			ril_radio_state_update(RADIO_STATE_SIM_NOT_READY);
 			break;
 	}
-- 
2.11.0


From 16be576726dc22d065e031a96f19be0cf5e8bd61 Mon Sep 17 00:00:00 2001
From: xc-racer99 <xc-racer2@live.ca>
Date: Mon, 23 Apr 2018 19:33:15 -0700
Subject: [PATCH 2/8] Check for pending requests when aseq is invalid for
 available networks

Some devices fail to retain aseq when returning available networks
---
 network.c | 20 +++++++++++++++-----
 1 file changed, 15 insertions(+), 5 deletions(-)

diff --git a/network.c b/network.c
index 9295ea7..4824631 100644
--- a/network.c
+++ b/network.c
@@ -732,6 +732,8 @@ int ril_request_operator(void *data, size_t size, RIL_Token token)
 int ipc_net_plmn_list(struct ipc_message *message)
 {
 	struct ipc_net_plmn_list_entry *entry;
+	struct ril_request *request;
+	RIL_Token token;
 	char **networks = NULL;
 	size_t networks_size;
 	unsigned int networks_count = 0;
@@ -748,12 +750,20 @@ int ipc_net_plmn_list(struct ipc_message *message)
 	if (rc < 0)
 		return 0;
 
-	if (message->type != IPC_TYPE_RESP || !ipc_seq_valid(message->aseq))
-		return 0;
+	if (message->type != IPC_TYPE_RESP || !ipc_seq_valid(message->aseq)) {
+		// Some devices don't properly set the aseq here
+		request = ril_request_find_request_status(RIL_REQUEST_QUERY_AVAILABLE_NETWORKS, RIL_REQUEST_HANDLED);
+		if (request == NULL || request->token == NULL)
+			return 0;
+		else
+			token = request->token;
+	} else {
+		token = ipc_fmt_request_token(message->aseq);
+	}
 
 	count = ipc_net_plmn_list_count_extract(message->data, message->size);
 	if (count == 0) {
-		ril_request_complete(ipc_fmt_request_token(message->aseq), RIL_E_SUCCESS, NULL, 0);
+		ril_request_complete(token, RIL_E_SUCCESS, NULL, 0);
 		return 0;
 	}
 
@@ -793,12 +803,12 @@ int ipc_net_plmn_list(struct ipc_message *message)
 
 	networks_size = networks_count * 4 * sizeof(char *);
 
-	ril_request_complete(ipc_fmt_request_token(message->aseq), RIL_E_SUCCESS, (void *) networks, networks_size);
+	ril_request_complete(token, RIL_E_SUCCESS, (void *) networks, networks_size);
 
 	goto complete;
 
 error:
-	ril_request_complete(ipc_fmt_request_token(message->aseq), RIL_E_GENERIC_FAILURE, NULL, 0);
+	ril_request_complete(token, RIL_E_GENERIC_FAILURE, NULL, 0);
 
 complete:
 	if (networks != NULL && networks_size > 0) {
-- 
2.11.0


From 04b0f3254344448cbf9edc2fc57bf47ebc8134e7 Mon Sep 17 00:00:00 2001
From: xc-racer99 <xc-racer2@live.ca>
Date: Mon, 30 Apr 2018 17:26:08 -0700
Subject: [PATCH 3/8] Check for pending requests when aseq is invalid for SMS

---
 sms.c | 32 ++++++++++++++++++++++++++------
 1 file changed, 26 insertions(+), 6 deletions(-)

diff --git a/sms.c b/sms.c
index 85fc950..4548a3c 100644
--- a/sms.c
+++ b/sms.c
@@ -81,13 +81,23 @@ unsigned char ril2ipc_sms_status(int status)
 int ipc_sms_send_msg(struct ipc_message *message)
 {
 	struct ipc_sms_send_msg_response_data *data;
+	struct ril_request *request;
 	RIL_SMS_Response response;
+	RIL_Token token;
 
 	if (message == NULL || message->data == NULL || message->size < sizeof(struct ipc_sms_send_msg_response_data))
 		return -1;
 
-	if (!ipc_seq_valid(message->aseq))
-		return 0;
+	if (!ipc_seq_valid(message->aseq)) {
+		// Some devices don't properly set the aseq here
+		request = ril_request_find_request_status(RIL_REQUEST_SEND_SMS, RIL_REQUEST_HANDLED);
+		if (request == NULL || request->token == NULL)
+			return 0;
+		else
+			token = request->token;
+	} else {
+		token = ipc_fmt_request_token(message->aseq);
+	}
 
 	data = (struct ipc_sms_send_msg_response_data *) message->data;
 
@@ -95,7 +105,7 @@ int ipc_sms_send_msg(struct ipc_message *message)
 	response.messageRef = data->id;
 	response.ackPDU = NULL;
 
-	ril_request_complete(ipc_fmt_request_token(message->aseq), ipc2ril_sms_ack_error(data->ack), &response, sizeof(response));
+	ril_request_complete(token, ipc2ril_sms_ack_error(data->ack), &response, sizeof(response));
 
 	return 0;
 }
@@ -500,19 +510,29 @@ complete:
 int ipc_sms_deliver_report(struct ipc_message *message)
 {
 	struct ipc_sms_deliver_report_response_data *data;
+	struct ril_request *request;
+	RIL_Token token;
 	RIL_Errno error;
 
 	if (message == NULL || message->data == NULL || message->size < sizeof(struct ipc_sms_deliver_report_response_data))
 		return -1;
 
-	if (!ipc_seq_valid(message->aseq))
-		return 0;
+	if (!ipc_seq_valid(message->aseq)) {
+		// Some devices don't properly set the aseq here
+		request = ril_request_find_request_status(RIL_REQUEST_SMS_ACKNOWLEDGE, RIL_REQUEST_HANDLED);
+		if (request == NULL || request->token == NULL)
+			return 0;
+		else
+			token = request->token;
+	} else {
+		token = ipc_fmt_request_token(message->aseq);
+	}
 
 	data = (struct ipc_sms_deliver_report_response_data *) message->data;
 
 	error = ipc2ril_sms_ack_error(data->ack);
 
-	ril_request_complete(ipc_fmt_request_token(message->aseq), error, NULL, 0);
+	ril_request_complete(token, error, NULL, 0);
 
 	return 0;
 }
-- 
2.11.0


From 7ccc64096bf9d69faba1d0fb7498765637c35b58 Mon Sep 17 00:00:00 2001
From: xc-racer99 <xc-racer2@live.ca>
Date: Tue, 24 Apr 2018 12:56:29 -0700
Subject: [PATCH 4/8] Handle generic responses when necessary

Some IPC FMT responses come through as generic, but because they are the actually responses, they can block other requests from being sent.  This is especially an issue if the request that errored out is SIM_IO/RSIM_ACCESS
---
 gen.c | 17 +++++++++++++++--
 1 file changed, 15 insertions(+), 2 deletions(-)

diff --git a/gen.c b/gen.c
index 8bfdb13..3b1525f 100644
--- a/gen.c
+++ b/gen.c
@@ -226,6 +226,7 @@ int ipc_gen_phone_res(struct ipc_message *message)
 	struct ipc_gen_phone_res_expect *expect;
 	struct ipc_gen_phone_res_data *data;
 	struct ril_client *client;
+	RIL_Token token;
 	RIL_Errno error;
 	int rc;
 
@@ -240,8 +241,20 @@ int ipc_gen_phone_res(struct ipc_message *message)
 
 	expect = ipc_gen_phone_res_expect_find_aseq(client, message->aseq);
 	if (expect == NULL) {
-		RIL_LOGD("Ignoring generic response for command %s", ipc_command_string(IPC_COMMAND(data->group, data->index)));
-		return 0;
+		if (message->type == IPC_TYPE_RESP) {
+			token = ipc_fmt_request_token(message->aseq);
+			if (token != NULL) {
+				RIL_LOGD("Received generic response for command %s, sending GENERIC_FAILURE", ipc_command_string(IPC_COMMAND(data->group, data->index)));
+				ril_request_complete(token, RIL_E_GENERIC_FAILURE, NULL, 0);
+				return 0;
+			} else {
+				RIL_LOGE("Expected to find request for generic response to command %s but unable to, igorning", ipc_command_string(IPC_COMMAND(data->group, data->index)));
+				return 0;
+			}
+		} else {
+			RIL_LOGD("Ignoring generic response for command %s", ipc_command_string(IPC_COMMAND(data->group, data->index)));
+			return 0;
+		}
 	}
 
 	if (IPC_COMMAND(data->group, data->index) != expect->command) {
-- 
2.11.0


From edebe2fc53a01413d0f23aedd20b8421326393d9 Mon Sep 17 00:00:00 2001
From: xc-racer99 <xc-racer2@live.ca>
Date: Mon, 23 Apr 2018 14:01:26 -0700
Subject: [PATCH 5/8] Use proper struct size in network

Previously what was used here was the same size, but other devices use a smaller value
---
 network.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/network.c b/network.c
index 4824631..19fd7f5 100644
--- a/network.c
+++ b/network.c
@@ -645,7 +645,7 @@ int ipc_net_serving_network(struct ipc_message *message)
 	unsigned int i;
 	int rc;
 
-	if (message == NULL || message->data == NULL || message->size < sizeof(struct ipc_net_regist_response_data))
+	if (message == NULL || message->data == NULL || message->size < sizeof(struct ipc_net_serving_network_data))
 		return -1;
 
 	rc = ril_radio_state_check(RADIO_STATE_SIM_NOT_READY);
-- 
2.11.0


From 92c3df0bbf40c3f411e001760a8ba151938e6b86 Mon Sep 17 00:00:00 2001
From: xc-racer99 <xc-racer2@live.ca>
Date: Thu, 26 Apr 2018 11:43:28 -0700
Subject: [PATCH 6/8] Voice calls can also be the default call type

Some devices don't set call type, so assume voice
---
 call.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/call.c b/call.c
index 6a3ffb9..9a6696a 100644
--- a/call.c
+++ b/call.c
@@ -297,7 +297,7 @@ int ipc_call_list(struct ipc_message *message)
 		calls[index]->isMpty = entry->mpty;
 		calls[index]->isMT = entry->term == IPC_CALL_TERM_MT;
 		calls[index]->als = 0;
-		calls[index]->isVoice = entry->type == IPC_CALL_TYPE_VOICE;
+		calls[index]->isVoice = entry->type == IPC_CALL_TYPE_VOICE || entry->type == IPC_CALL_TYPE_DEFAULT;
 		calls[index]->isVoicePrivacy = 0;
 		calls[index]->number = strdup(number);
 		calls[index]->numberPresentation = (entry->number_length > 0) ? 0 : 2;
-- 
2.11.0


From e14b300400f884a95c209dc3b2ef4202e75428db Mon Sep 17 00:00:00 2001
From: xc-racer99 <xc-racer2@live.ca>
Date: Tue, 1 May 2018 09:23:10 -0700
Subject: [PATCH 7/8] Use valid call id when given id is 0

Some devices start their indexing at 0, but Android wants it to start at 1.
Considering that this id value is never used by the modem again, this should be safe
---
 call.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/call.c b/call.c
index 9a6696a..0c7f1d6 100644
--- a/call.c
+++ b/call.c
@@ -293,7 +293,7 @@ int ipc_call_list(struct ipc_message *message)
 
 		calls[index] = (RIL_Call *) calloc(1, sizeof(RIL_Call));
 		calls[index]->state = ipc2ril_call_list_entry_state(entry->status);
-		calls[index]->index = entry->id;
+		calls[index]->index = (entry->id == 0) ? index + 1 : entry->id;
 		calls[index]->isMpty = entry->mpty;
 		calls[index]->isMT = entry->term == IPC_CALL_TERM_MT;
 		calls[index]->als = 0;
-- 
2.11.0


From 95d5cdd5238ad352de4bce9f037035c528283db3 Mon Sep 17 00:00:00 2001
From: Jonathan Bakker <xc-racer2@live.ca>
Date: Fri, 21 Sep 2018 13:39:36 -0700
Subject: [PATCH 8/8] Implement more RFS commands

These commands are used by the 4G HSPA+ versions of the first gen Galaxy S series.
---
 rfs.c         | 498 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 samsung-ril.c |  52 ++++++
 samsung-ril.h |   3 +
 3 files changed, 553 insertions(+)

diff --git a/rfs.c b/rfs.c
index 74d5325..e1c7e32 100644
--- a/rfs.c
+++ b/rfs.c
@@ -17,7 +17,11 @@
  * along with Samsung-RIL.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include <dirent.h>
 #include <stdlib.h>
+#include <sys/stat.h>
+#include <string.h>
+#include <limits.h>     /* PATH_MAX */
 
 #define LOG_TAG "RIL-RFS"
 #include <utils/Log.h>
@@ -146,3 +150,497 @@ int ipc_rfs_nv_write_item(struct ipc_message *message)
 
 	return 0;
 }
+
+int ipc_rfs_read_dir(struct ipc_message *message)
+{
+	struct ipc_rfs_read_dir_request_header *header;
+	struct ipc_rfs_read_dir_response_header *response_header;
+	struct dirent *dirent;
+	DIR *dirp;
+	void *buffer;
+	size_t len;
+	int rc;
+
+	if (message == NULL || message->data == NULL || message->size < sizeof(struct ipc_rfs_read_dir_request_header))
+		return -1;
+
+	header = (struct ipc_rfs_read_dir_request_header *) message->data;
+
+	dirp = (DIR *) header->addr;
+
+	dirent = readdir(dirp);
+	if (dirent == NULL) {
+		len = sizeof(struct ipc_rfs_read_dir_response_header);
+		buffer = calloc(1, len);
+		if (buffer == NULL)
+			return -1;
+		response_header = (struct ipc_rfs_read_dir_response_header *) buffer;
+		response_header->ret = -1;
+		response_header->err = errno;
+	} else {
+		len = sizeof(struct ipc_rfs_read_dir_response_header) + strlen(dirent->d_name);
+		buffer = calloc(1, len);
+		if (buffer == NULL)
+			return -1;
+		response_header = (struct ipc_rfs_read_dir_response_header *) buffer;
+		response_header->len = strlen(dirent->d_name);
+		strcpy((char *) buffer + sizeof(struct ipc_rfs_read_dir_response_header), dirent->d_name);
+	}
+
+	rc = ipc_rfs_send(message->aseq, IPC_RFS_READ_DIR, buffer, len);
+
+	free(buffer);
+
+	return 0;
+}
+
+int mkdir_p(const char *path, size_t len)
+{
+    /* Adapted from http://stackoverflow.com/a/2336245/119527 */
+    char _path[PATH_MAX];
+    char *p;
+
+    errno = 0;
+
+    /* Copy string so its mutable */
+    if (len > sizeof(_path)-1) {
+        errno = ENAMETOOLONG;
+        return -1;
+    }
+    strncpy(_path, path, len);
+
+    /* Iterate the string */
+    for (p = _path + 1; *p; p++) {
+        if (*p == '/') {
+            /* Temporarily truncate */
+            *p = '\0';
+
+            if (mkdir(_path, S_IRWXU) != 0) {
+                if (errno != EEXIST)
+                    return -1;
+            }
+
+            *p = '/';
+        }
+    }
+
+    if (mkdir(_path, S_IRWXU) != 0) {
+        if (errno != EEXIST)
+            return -1;
+    }
+
+    return 0;
+}
+
+int ipc_rfs_make_path(struct ipc_client *client, char *path, char *rel_path, int rel_path_len)
+{
+	int rel_path_pos = 0;
+	char *p;
+	char *efs_root;
+
+	if (rel_path == NULL) {
+		RIL_LOGE("rel_path is null");
+		return -1;
+	}
+
+	efs_root = ipc_client_efs_root(client);
+	if (efs_root == NULL) {
+		RIL_LOGE("Failed to read efs_root");
+		return -1;
+	}
+
+	/* Combine efs_root and rel_path */
+	strcpy(path, efs_root);
+	strncat(path, rel_path, rel_path_len);
+
+	/* See how many subdirectories we start in */
+	p = efs_root;
+	while (strstr(p, "/") != NULL) {
+		p += 1;
+		rel_path_pos--;
+	}
+
+	/* Count number of times we go up a directory */
+	p = path;
+	while (strstr(p, "/../") != NULL) {
+		p += 4;
+		rel_path_pos--;
+	}
+
+	/* Count number of directory separators */
+	p = path;
+	while (strstr(p, "/") != NULL) {
+		p += 1;
+		rel_path_pos++;
+	}
+
+	/* Count number of doubled directory separators */
+	p = path;
+	while (strstr(p, "//") != NULL) {
+		p += 1;
+		rel_path_pos--;
+	}
+
+	/* Make sure we're not trying to go above efs_root */
+	if (rel_path_pos < 0) {
+		RIL_LOGE("WARNING: RIL is trying to access files outside of /efs/, denying access");
+		return -1;
+	}
+
+	RIL_LOGD("Created path %s", path);
+
+	return 0;
+}
+
+int ipc_rfs_generic_io(struct ipc_message *message)
+{
+	struct ipc_rfs_generic_io_response_header data;
+	struct ril_client *client;
+	struct ipc_rfs_data *ipc_rfs_data;
+	int rc;
+
+	if (message == NULL || message->data == NULL)
+		return -1;
+
+	client = ril_client_find_id(RIL_CLIENT_IPC_RFS);
+	if (client == NULL || client->data == NULL)
+		return 0;
+
+	ipc_rfs_data = (struct ipc_rfs_data *) client->data;
+	if (ipc_rfs_data->ipc_client == NULL)
+		return 0;
+
+	memset(&data, 0, sizeof(data));
+
+	switch (message->command) {
+		case IPC_RFS_READ_FILE:
+		{
+			if (message->size < sizeof(struct ipc_rfs_read_file_request_header))
+				return -1;
+
+			struct ipc_rfs_read_file_request_header *header =
+					(struct ipc_rfs_read_file_request_header *) message->data;
+			struct ipc_rfs_generic_io_response_header *response;
+
+			/* Special case - we need a bigger buffer */
+			void *buf = alloca(sizeof(struct ipc_rfs_generic_io_response_header) + header->len);
+			if (buf == NULL) {
+				RIL_LOGE("alloca failed");
+				goto error;
+			}
+
+			rc = read(header->fd,
+					(char *) ((char *) buf + sizeof(struct ipc_rfs_generic_io_response_header)),
+					header->len);
+
+			response = buf;
+
+			response->ret = rc;
+
+			if (response->ret == 0)
+				response->err = ENOENT;
+			else if (response->ret < 0)
+				response->err = errno;
+			else
+				response->err = 0;
+
+			rc = ipc_rfs_send(message->aseq, message->command, response,
+					sizeof(struct ipc_rfs_generic_io_response_header) + response->ret);
+
+			return 0;
+		}
+		case IPC_RFS_WRITE_FILE:
+		{
+			if (message->size < sizeof(struct ipc_rfs_write_file_request_header))
+				return -1;
+
+			struct ipc_rfs_write_file_request_header *header =
+					(struct ipc_rfs_write_file_request_header *) message->data;
+
+			data.ret = write(header->fd,
+					header + sizeof(struct ipc_rfs_write_file_request_header),
+					header->len);
+			break;
+		}
+		case IPC_RFS_LSEEK_FILE:
+		{
+			if (message->size < sizeof(struct ipc_rfs_lseek_file_request_header))
+				return -1;
+
+			struct ipc_rfs_lseek_file_request_header *header =
+					(struct ipc_rfs_lseek_file_request_header *) message->data;
+			data.ret = lseek(header->fd, header->offset, header->whence);
+			break;
+		}
+		case IPC_RFS_CLOSE_FILE:
+		{
+			if (message->size < sizeof(struct ipc_rfs_close_file_request_header))
+				return -1;
+
+			struct ipc_rfs_close_file_request_header *header =
+					(struct ipc_rfs_close_file_request_header *) message->data;
+			data.ret = close(header->fd);
+			break;
+		}
+		case IPC_RFS_RENAME_FILE:
+		{
+			if (message->size < sizeof(struct ipc_rfs_rename_file_request_header))
+				return -1;
+
+			struct ipc_rfs_rename_file_request_header *header1 =
+					(struct ipc_rfs_rename_file_request_header *) message->data;
+			struct ipc_rfs_rename_file_request_header *header2 =
+					(struct ipc_rfs_rename_file_request_header *)
+					((char *) message->data
+					+ sizeof(struct ipc_rfs_rename_file_request_header)
+					+ header1->path_len);
+			char oldpath[PATH_MAX];
+			char newpath[PATH_MAX];;
+
+			rc = ipc_rfs_make_path(ipc_rfs_data->ipc_client, oldpath,
+					(char *) header1 + sizeof(struct ipc_rfs_rename_file_request_header),
+					header1->path_len);
+
+			if (rc < 0) {
+				RIL_LOGE("ipc_rfs_make_path failed");
+				goto error;
+			}
+
+			rc = ipc_rfs_make_path(ipc_rfs_data->ipc_client, newpath,
+					(char *) header2 + sizeof(struct ipc_rfs_rename_file_request_header),
+					header2->path_len);
+
+			if (rc < 0) {
+				RIL_LOGE("ipc_rfs_make_path failed");
+				goto error;
+			}
+
+			data.ret = rename(oldpath, newpath);
+			break;
+		}
+		case IPC_RFS_UNLINK_FILE:
+		{
+			if (message->size < sizeof(struct ipc_rfs_unlink_file_request_header))
+				return -1;
+
+			struct ipc_rfs_unlink_file_request_header *header =
+					(struct ipc_rfs_unlink_file_request_header *) message->data;
+			char path[PATH_MAX];
+			rc = ipc_rfs_make_path(ipc_rfs_data->ipc_client, path,
+					(char *) message->data + sizeof(struct ipc_rfs_unlink_file_request_header),
+					header->path_len);
+			if (rc < 0)
+				goto error;
+			rc = unlink(path);
+			if (rc < 0 && errno == ENOENT)
+				rc = 0;
+			data.ret = rc;
+
+			break;
+		}
+		case IPC_RFS_MAKE_DIR:
+		{
+			if (message->size < sizeof(struct ipc_rfs_make_dir_request_header))
+				return -1;
+
+			struct stat buf;
+			struct ipc_rfs_make_dir_request_header *header =
+					(struct ipc_rfs_make_dir_request_header *) message->data;
+			char path[PATH_MAX];
+			rc = ipc_rfs_make_path(ipc_rfs_data->ipc_client, path,
+					(char *) message->data + sizeof(struct ipc_rfs_make_dir_request_header),
+					header->path_len);
+			if (rc < 0)
+				goto error;
+			rc = stat(path, &buf);
+			if (rc < 0 && errno == ENOENT)
+				rc = mkdir(path, 0660);
+			data.ret = rc;
+			break;
+		}
+		case IPC_RFS_REMOVE_DIR:
+		{
+			if (message->size < sizeof(struct ipc_rfs_remove_dir_request_header))
+				return -1;
+
+			struct ipc_rfs_remove_dir_request_header *header =
+					(struct ipc_rfs_remove_dir_request_header *) message->data;
+			char path[PATH_MAX];
+			rc = ipc_rfs_make_path(ipc_rfs_data->ipc_client, path,
+					(char *) message->data + sizeof(struct ipc_rfs_remove_dir_request_header),
+					header->path_len);
+			if (rc < 0)
+				goto error;
+			data.ret = rmdir(path);
+			break;
+		}
+		case IPC_RFS_OPEN_DIR:
+		{
+			if (message->size < sizeof(struct ipc_rfs_open_dir_request_header))
+				return -1;
+
+			DIR *dirp;
+			struct ipc_rfs_open_dir_request_header *header =
+					(struct ipc_rfs_open_dir_request_header *) message->data;
+			char path[PATH_MAX];
+			rc = ipc_rfs_make_path(ipc_rfs_data->ipc_client, path,
+					(char *) message->data + sizeof(struct ipc_rfs_open_dir_request_header),
+					header->path_len);
+			if (rc < 0)
+				goto error;
+			dirp = opendir(path);
+			if (dirp)
+				data.ret = (int) dirp;
+			else
+				data.ret = -1;
+			break;
+		}
+		case IPC_RFS_CLOSE_DIR:
+		{
+			if (message->size < sizeof(struct ipc_rfs_close_dir_request_header))
+				return -1;
+
+			struct ipc_rfs_close_dir_request_header *header =
+					(struct ipc_rfs_close_dir_request_header *) message->data;
+			data.ret = closedir((DIR *) header->addr);
+			break;
+		}
+		case IPC_RFS_OPEN_FILE:
+		{
+			if (message->size < sizeof(struct ipc_rfs_open_file_request_header))
+				return -1;
+
+			struct ipc_rfs_open_file_request_header *header =
+					(struct ipc_rfs_open_file_request_header *) message->data;
+			char path[PATH_MAX];
+			rc = ipc_rfs_make_path(ipc_rfs_data->ipc_client, path,
+					(char *) message->data + sizeof(struct ipc_rfs_open_file_request_header),
+					header->path_len);
+			if (rc < 0)
+				goto error;
+			if (header->flags & O_CREAT) {
+				RIL_LOGD("Recursively creating directory and files");
+
+				char *index = strrchr(path, '/');
+				if (index != NULL)
+					mkdir_p(path, index - path);
+			}
+			data.ret = open(path, header->flags | O_DSYNC, 0644);
+			break;
+		}
+		default:
+		{
+			RIL_LOGE("Unknown generic IO command %d", message->command);
+			goto error;
+		}
+	}
+
+	if (data.ret < 0)
+		data.err = errno;
+
+	rc = ipc_rfs_send(message->aseq, message->command, &data,
+			sizeof(struct ipc_rfs_generic_io_response_header));
+
+	return 0;
+
+error:
+	data.ret = -1;
+	data.err = EPERM;
+
+	rc = ipc_rfs_send(message->aseq, message->command, &data,
+			sizeof(struct ipc_rfs_generic_io_response_header));
+
+	return 0;
+}
+
+int ipc_rfs_file_info(struct ipc_message *message)
+{
+	struct ril_client *client;
+	struct ipc_rfs_data *ipc_rfs_data;
+	struct ipc_rfs_file_info_response_data data;
+	struct stat buf;
+	struct tm result;
+	char path[PATH_MAX];
+	int rc;
+
+	if (message == NULL || message->data == NULL)
+		return -1;
+
+	client = ril_client_find_id(RIL_CLIENT_IPC_RFS);
+	if (client == NULL || client->data == NULL)
+		return 0;
+
+	ipc_rfs_data = (struct ipc_rfs_data *) client->data;
+	if (ipc_rfs_data->ipc_client == NULL)
+		return 0;
+
+	memset(&data, 0, sizeof(data));
+
+	if (message->command == IPC_RFS_GET_FILE_INFO) {
+		if (message->size < sizeof(struct ipc_rfs_get_file_info_request_header))
+			return -1;
+
+		struct ipc_rfs_get_file_info_request_header *header =
+				(struct ipc_rfs_get_file_info_request_header *) message->data;
+
+		rc = ipc_rfs_make_path(ipc_rfs_data->ipc_client, path,
+				(char*) message->data + sizeof(struct ipc_rfs_get_file_info_request_header),
+				header->path_len);
+		if (rc < 0) {
+			data.ret = -1;
+			data.err = EPERM;
+			goto out;
+		}
+
+		rc = stat(path, &buf);
+	} else if (message->command == IPC_RFS_GET_HANDLE_INFO) {
+		if (message->size < sizeof(struct ipc_rfs_get_handle_info_request_header))
+			return -1;
+
+		struct ipc_rfs_get_handle_info_request_header *header =
+				(struct ipc_rfs_get_handle_info_request_header *) message->data;
+
+		rc = fstat(header->fd, &buf);
+	} else {
+		RIL_LOGE("Unknown command %d for %s", message->command, __func__);
+		return -1;
+	}
+
+	if (rc < 0) {
+		data.ret = rc;
+		data.err = errno;
+	} else {
+		if (S_ISDIR(buf.st_mode)) {
+			data.type = IPC_RFS_TYPE_DIRECTORY;
+		} else if (S_ISREG(buf.st_mode)) {
+			data.type = IPC_RFS_TYPE_FILE;
+		} else {
+			RIL_LOGE("Unknown file type, setting to 0");
+			data.type = IPC_RFS_TYPE_UNKNOWN;
+		}
+		data.size = buf.st_size;
+
+		// Store creation times
+		localtime_r((time_t *) &buf.st_ctime, &result);
+		data.c_year = (unsigned char) (result.tm_year  - 100);
+		data.c_month = (unsigned char) (result.tm_mon + 1);
+		data.c_day = (unsigned char) result.tm_mday;
+		data.c_hour = (unsigned char) result.tm_hour;
+		data.c_min = (unsigned char) result.tm_min;
+		data.c_sec = (unsigned char) result.tm_sec;
+
+		// Store modification times
+		localtime_r((time_t *) &buf.st_mtime, &result);
+		data.m_year = (unsigned char) (result.tm_year  - 100);
+		data.m_month = (unsigned char) (result.tm_mon + 1);
+		data.m_day = (unsigned char) result.tm_mday;
+		data.m_hour = (unsigned char) result.tm_hour;
+		data.m_min = (unsigned char) result.tm_min;
+		data.m_sec = (unsigned char) result.tm_sec;
+	}
+
+out:
+	rc = ipc_rfs_send(message->aseq, message->command, (void *) &data, sizeof(data));
+
+	return 0;
+}
diff --git a/samsung-ril.c b/samsung-ril.c
index 9f13b86..53f1524 100644
--- a/samsung-ril.c
+++ b/samsung-ril.c
@@ -220,6 +220,58 @@ struct ipc_dispatch_handler ipc_rfs_dispatch_handlers[] = {
 		.command = IPC_RFS_NV_WRITE_ITEM,
 		.handler = ipc_rfs_nv_write_item,
 	},
+	{
+		.command = IPC_RFS_READ_FILE,
+		.handler = ipc_rfs_generic_io,
+	},
+	{
+		.command = IPC_RFS_WRITE_FILE,
+		.handler = ipc_rfs_generic_io,
+	},
+	{
+		.command = IPC_RFS_LSEEK_FILE,
+		.handler = ipc_rfs_generic_io,
+	},
+	{
+		.command = IPC_RFS_CLOSE_FILE,
+		.handler = ipc_rfs_generic_io,
+	},
+	{
+		.command = IPC_RFS_GET_FILE_INFO,
+		.handler = ipc_rfs_file_info,
+	},
+	{
+		.command = IPC_RFS_RENAME_FILE,
+		.handler = ipc_rfs_generic_io,
+	},
+	{
+		.command = IPC_RFS_UNLINK_FILE,
+		.handler = ipc_rfs_generic_io,
+	},
+	{
+		.command = IPC_RFS_MAKE_DIR,
+		.handler = ipc_rfs_generic_io,
+	},
+	{
+		.command = IPC_RFS_OPEN_DIR,
+		.handler = ipc_rfs_generic_io,
+	},
+	{
+		.command = IPC_RFS_READ_DIR,
+		.handler = ipc_rfs_read_dir,
+	},
+	{
+		.command = IPC_RFS_CLOSE_DIR,
+		.handler = ipc_rfs_generic_io,
+	},
+	{
+		.command = IPC_RFS_OPEN_FILE,
+		.handler = ipc_rfs_generic_io,
+	},
+	{
+		.command = IPC_RFS_GET_HANDLE_INFO,
+		.handler = ipc_rfs_file_info,
+	},
 };
 
 unsigned int ipc_rfs_dispatch_handlers_count = sizeof(ipc_rfs_dispatch_handlers) /
diff --git a/samsung-ril.h b/samsung-ril.h
index cf6dc15..2d59877 100644
--- a/samsung-ril.h
+++ b/samsung-ril.h
@@ -439,6 +439,9 @@ int ril_request_last_data_call_fail_cause(void *data, size_t size,
 
 int ipc_rfs_nv_read_item(struct ipc_message *message);
 int ipc_rfs_nv_write_item(struct ipc_message *message);
+int ipc_rfs_file_info(struct ipc_message *message);
+int ipc_rfs_generic_io(struct ipc_message *message);
+int ipc_rfs_read_dir(struct ipc_message *message);
 
 /*
  * GEN
-- 
2.11.0

