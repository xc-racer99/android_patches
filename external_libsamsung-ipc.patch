From 8d2a27bb01118517589ebf1e823160a0c803660c Mon Sep 17 00:00:00 2001
From: Jonathan Bakker <xc-racer2@live.ca>
Date: Thu, 3 Jan 2019 12:18:24 -0800
Subject: [PATCH 1/3] Add support for mainline  kernel and STE M5730 modems to
 Crespo driver

Some Galaxy S variants use an STE modem which has a different startup

Additionally, add some alternative paths for serial and modem image
devices as newer mainline kernels have some differences.

Also add a board name for S5PV210 mainline boards
---
 Android.mk                                    |   3 +-
 samsung-ipc/Makefile.am                       |   2 +
 samsung-ipc/devices/crespo/crespo.c           |  43 +-
 samsung-ipc/devices/crespo/crespo.h           |   7 +-
 samsung-ipc/devices/crespo/crespo_modem_ctl.h |   3 +
 samsung-ipc/devices/crespo/crespo_ste_m5730.c | 543 ++++++++++++++++++++++++++
 samsung-ipc/devices/crespo/ste_m5730.h        |  36 ++
 samsung-ipc/ipc_devices.c                     |  10 +
 8 files changed, 641 insertions(+), 6 deletions(-)
 create mode 100644 samsung-ipc/devices/crespo/crespo_ste_m5730.c
 create mode 100644 samsung-ipc/devices/crespo/ste_m5730.h

diff --git a/Android.mk b/Android.mk
index 3aa9dd0..541c63a 100644
--- a/Android.mk
+++ b/Android.mk
@@ -19,7 +19,7 @@ LOCAL_PATH := $(call my-dir)
 
 include $(CLEAR_VARS)
 
-ifneq (,$(filter crespo,$(TARGET_DEVICE)))
+ifneq (,$(filter crespo galaxys4gmtd fascinate4gmtd,$(TARGET_DEVICE)))
 	ipc_device_name := crespo
 endif
 
@@ -61,6 +61,7 @@ LOCAL_SRC_FILES := \
 	samsung-ipc/devices/xmm626/xmm626_mipi.c \
 	samsung-ipc/devices/xmm626/xmm626_sec_modem.c \
 	samsung-ipc/devices/crespo/crespo.c \
+	samsung-ipc/devices/crespo/crespo_ste_m5730.c \
 	samsung-ipc/devices/aries/aries.c \
 	samsung-ipc/devices/galaxys2/galaxys2.c \
 	samsung-ipc/devices/maguro/maguro.c \
diff --git a/samsung-ipc/Makefile.am b/samsung-ipc/Makefile.am
index 1dda9c2..7bdfd37 100644
--- a/samsung-ipc/Makefile.am
+++ b/samsung-ipc/Makefile.am
@@ -36,8 +36,10 @@ libsamsung_ipc_la_SOURCES = \
 	devices/xmm626/modem_link_device_hsic.h \
 	devices/xmm626/modem_prj.h \
 	devices/crespo/crespo.c \
+	devices/crespo/crespo_ste_m5730.c \
 	devices/crespo/crespo.h \
 	devices/crespo/crespo_modem_ctl.h \
+	devices/crespo/ste_m5730.h \
 	devices/aries/aries.c \
 	devices/aries/aries.h \
 	devices/aries/onedram.h \
diff --git a/samsung-ipc/devices/crespo/crespo.c b/samsung-ipc/devices/crespo/crespo.c
index c6837e5..40dca27 100644
--- a/samsung-ipc/devices/crespo/crespo.c
+++ b/samsung-ipc/devices/crespo/crespo.c
@@ -26,6 +26,7 @@
 #include <stdbool.h>
 #include <string.h>
 #include <unistd.h>
+#include <errno.h>
 #include <fcntl.h>
 #include <sys/ioctl.h>
 #include <sys/select.h>
@@ -36,9 +37,10 @@
 #include "crespo_modem_ctl.h"
 
 #include "xmm616.h"
+#include "ste_m5730.h"
 #include "crespo.h"
 
-int crespo_boot(struct ipc_client *client)
+int crespo_xmm_boot(struct ipc_client *client)
 {
     void *modem_image_data = NULL;
     int modem_ctl_fd = -1;
@@ -51,7 +53,13 @@ int crespo_boot(struct ipc_client *client)
 
     ipc_client_log(client, "Starting crespo modem boot");
 
-    modem_image_data = file_data_read(CRESPO_MODEM_IMAGE_DEVICE, CRESPO_MODEM_IMAGE_SIZE, 0x1000, 0);
+    /* Try alternative modem image device first as the main one may exist
+     * even when it doesn't contain the modem
+     */
+    modem_image_data = file_data_read(CRESPO_ALT_MODEM_IMAGE_DEVICE, CRESPO_XMM_MODEM_IMAGE_SIZE, 0x1000, 0);
+    if (modem_image_data == NULL)
+        modem_image_data = file_data_read(CRESPO_MODEM_IMAGE_DEVICE, CRESPO_XMM_MODEM_IMAGE_SIZE, 0x1000, 0);
+
     if (modem_image_data == NULL) {
         ipc_client_log(client, "Reading modem image data failed");
         goto error;
@@ -73,6 +81,9 @@ int crespo_boot(struct ipc_client *client)
     ipc_client_log(client, "Reset modem");
 
     serial_fd = open(CRESPO_MODEM_SERIAL_DEVICE, O_RDWR | O_NDELAY);
+    if (serial_fd < 0 && errno == ENOENT)
+        serial_fd = open(CRESPO_ALT_MODEM_SERIAL_DEVICE, O_RDWR | O_NDELAY);
+
     if (serial_fd < 0) {
         ipc_client_log(client, "Opening serial failed");
         goto error;
@@ -94,7 +105,7 @@ int crespo_boot(struct ipc_client *client)
 
     lseek(modem_ctl_fd, 0, SEEK_SET);
 
-    rc = xmm616_firmware_send(client, modem_ctl_fd, NULL, (void *) p, CRESPO_MODEM_IMAGE_SIZE - CRESPO_PSI_SIZE);
+    rc = xmm616_firmware_send(client, modem_ctl_fd, NULL, (void *) p, CRESPO_XMM_MODEM_IMAGE_SIZE - CRESPO_PSI_SIZE);
     if (rc < 0) {
         ipc_client_log(client, "Sending XMM616 firmware failed");
         goto error;
@@ -129,6 +140,21 @@ complete:
     return rc;
 }
 
+int crespo_boot(struct ipc_client *client)
+{
+    int rc;
+
+    if (crespo_is_ste()) {
+        ipc_client_log(client, "Detected an STE M5730 modem");
+        rc = crespo_ste_boot(client);
+    } else {
+        ipc_client_log(client, "Detected an XMM6160 modem");
+        rc = crespo_xmm_boot(client);
+    }
+
+    return rc;
+}
+
 int crespo_fmt_send(struct ipc_client *client, struct ipc_message *message)
 {
     struct ipc_fmt_header header;
@@ -444,7 +470,7 @@ int crespo_poll(void *data, struct ipc_poll_fds *fds, struct timeval *timeout)
     return rc;
 }
 
-int crespo_power_on(void *data)
+int crespo_xmm_power_on(void *data)
 {
     int fd;
     int rc;
@@ -463,6 +489,14 @@ int crespo_power_on(void *data)
     return 0;
 }
 
+int crespo_power_on(void *data)
+{
+    if (crespo_is_ste())
+        return crespo_ste_power_on(data);
+
+    return crespo_xmm_power_on(data);
+}
+
 int crespo_power_off(void *data)
 {
     int fd;
@@ -594,6 +628,7 @@ struct ipc_client_gprs_specs crespo_gprs_specs = {
 };
 
 struct ipc_client_nv_data_specs crespo_nv_data_specs = {
+    .efs_root = CRESPO_EFS_ROOT,
     .nv_data_path = XMM616_NV_DATA_PATH,
     .nv_data_md5_path = XMM616_NV_DATA_MD5_PATH,
     .nv_data_backup_path = XMM616_NV_DATA_BACKUP_PATH,
diff --git a/samsung-ipc/devices/crespo/crespo.h b/samsung-ipc/devices/crespo/crespo.h
index 97dff96..b02dd97 100644
--- a/samsung-ipc/devices/crespo/crespo.h
+++ b/samsung-ipc/devices/crespo/crespo.h
@@ -20,13 +20,16 @@
 #ifndef __CRESPO_H__
 #define __CRESPO_H__
 
-#define CRESPO_MODEM_IMAGE_SIZE                                 0xD80000
+#define CRESPO_XMM_MODEM_IMAGE_SIZE                             0xD80000
+#define CRESPO_STE_MODEM_IMAGE_SIZE                             0xE05000
 #define CRESPO_PSI_SIZE                                         0x5000
 #define CRESPO_MODEM_CTL_NV_DATA_OFFSET                         0xD80000
 #define CRESPO_BUFFER_LENGTH                                    0x50000
 
 #define CRESPO_MODEM_IMAGE_DEVICE               "/dev/mtd/mtd5ro"
+#define CRESPO_ALT_MODEM_IMAGE_DEVICE           "/radio/modem.bin"
 #define CRESPO_MODEM_SERIAL_DEVICE              "/dev/s3c2410_serial3"
+#define CRESPO_ALT_MODEM_SERIAL_DEVICE          "/dev/ttySAC3"
 #define CRESPO_MODEM_CTL_DEVICE                 "/dev/modem_ctl"
 #define CRESPO_MODEM_FMT_DEVICE                 "/dev/modem_fmt"
 #define CRESPO_MODEM_RFS_DEVICE                 "/dev/modem_rfs"
@@ -34,6 +37,8 @@
 #define CRESPO_GPRS_IFACE_PREFIX                "rmnet"
 #define CRESPO_GPRS_IFACE_COUNT                                 3
 
+#define CRESPO_EFS_ROOT                         "/efs/root"
+
 struct crespo_transport_data {
     int fd;
 };
diff --git a/samsung-ipc/devices/crespo/crespo_modem_ctl.h b/samsung-ipc/devices/crespo/crespo_modem_ctl.h
index 7c23165..355b5ed 100644
--- a/samsung-ipc/devices/crespo/crespo_modem_ctl.h
+++ b/samsung-ipc/devices/crespo/crespo_modem_ctl.h
@@ -24,6 +24,9 @@
 #define IOCTL_MODEM_SEND		_IO('o', 0x23)
 #define IOCTL_MODEM_RECV		_IO('o', 0x24)
 
+#define IOCTL_MODEM_WAIT_FOR_SBL	_IO('o', 0x25)
+#define IOCTL_MODEM_BINARY_LOAD		_IO('o', 0x26)
+
 struct modem_io {
 	uint32_t size;
 	uint32_t id;
diff --git a/samsung-ipc/devices/crespo/crespo_ste_m5730.c b/samsung-ipc/devices/crespo/crespo_ste_m5730.c
new file mode 100644
index 0000000..8baac4b
--- /dev/null
+++ b/samsung-ipc/devices/crespo/crespo_ste_m5730.c
@@ -0,0 +1,543 @@
+/*
+ * This file is part of libsamsung-ipc.
+ *
+ * Copyright (C) 2011 Joerie de Gram <j.de.gram@gmail.com>
+ * Copyright (C) 2011 Simon Busch <morphis@gravedo.de>
+ * Copyright (C) 2011-2014 Paul Kocialkowski <contact@paulk.fr>
+ *
+ * libsamsung-ipc is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libsamsung-ipc is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with libsamsung-ipc.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <termios.h>
+#include <sys/ioctl.h>
+#include <sys/select.h>
+
+#include <samsung-ipc.h>
+#include <checksum.h>
+#include <ipc.h>
+
+#include "crespo_modem_ctl.h"
+
+#include "xmm616.h"
+#include "ste_m5730.h"
+#include "crespo.h"
+
+const char* const send_protroms[] = {
+    "\x64",
+    "\x64\x88\x01",
+    "\x64\x88\x01\x04",
+    "\x04\x00",
+};
+
+int crespo_is_ste(void)
+{
+    char buf[10];
+    int fd, rc;
+
+    fd = open(CRESPO_MODEM_TYPE_SYSFS, O_RDONLY);
+    if (fd < 0)
+        return 0;
+
+    rc = read(fd, buf, 10);
+    if (strncmp(buf, "ste", 10))
+        rc = 1;
+    else
+        rc = 0;
+
+    close(fd);
+
+    return rc;
+}
+
+int m5730_write_baud_change(struct ipc_client *client, int serial_fd)
+{
+    struct timeval time;
+    fd_set fds;
+    unsigned char buf[8];
+    int rc;
+    int i;
+
+    usleep(110000);
+
+start_z_protocol:
+    /* Flush serial */
+    ioctl(serial_fd, TCFLSH, TCIOFLUSH);
+
+    /* Write b */
+    rc = write(serial_fd, "b", 1);
+    if (rc != 1) {
+        ipc_client_log(client, "Failed to write b");
+        return -1;
+    }
+    ipc_client_log(client, "Wrote b");
+
+    usleep(50000);
+
+    FD_ZERO(&fds);
+    FD_SET(serial_fd, &fds);
+
+    time.tv_sec = 60;
+    time.tv_usec = 0;
+
+    rc = select(serial_fd + 1, &fds, NULL, NULL, &time);
+    if (rc < 0) {
+        ipc_client_log(client, "Select encountered an error");
+        return -1;
+    }
+    if (!FD_ISSET(serial_fd, &fds)) {
+        ipc_client_log(client, "Nothing to read!");
+        return -1;
+    }
+
+    rc = read(serial_fd, buf, sizeof(buf));
+    if (rc == 1) {
+        /* If it's a z, resend b */
+        if (buf[0] == 'z')
+            goto start_z_protocol;
+
+        ipc_client_log(client, "Read unkown byte %c", buf[0]);
+        return -1;
+    } else if (rc != 8) {
+        ipc_client_log(client, "Didn't read 8 bytes, read %d bytes instead", rc);
+        return -1;
+    }
+
+    /* Just some debugging */
+    for (i = 0; i < rc; i++) {
+        ipc_client_log(client, "Buf[%d] = 0x%x", i, buf[i]);
+    }
+
+    /* Write S4 to change UART speed */
+    rc = write(serial_fd, "S4", 2);
+    if (rc != 2) {
+        ipc_client_log(client, "Failed to write S4 to change speed");
+        return -1;
+    }
+
+    ioctl(serial_fd, TCFLSH, TCIOFLUSH);
+
+    return 0;
+}
+
+int m5730_receive_protrom(int fd)
+{
+    int rc;
+    int i;
+    unsigned int ack;
+    unsigned char data[32];
+    fd_set fds;
+    struct timeval time;
+
+    ack = SERIAL_ACK;
+
+    time.tv_sec = 2;
+    time.tv_usec = 0;
+
+    FD_ZERO(&fds);
+    FD_SET(fd, &fds);
+
+    rc = select(fd + 1, &fds, NULL, NULL, &time);
+
+    if (rc < 0)
+        return rc;
+
+    if (!FD_ISSET(fd, &fds))
+        return -1;
+
+    rc = read(fd, data, sizeof(data));
+    if (rc <= 0)
+        return -1;
+
+    for (i = 0; i < rc; i++) {
+        if (memcmp(data + i, &ack, sizeof(ack)) == 0)
+            return 0;
+    }
+
+    /* Couldn't find ack */
+    return -1;
+}
+
+int m5730_send_protrom(int fd, int n)
+{
+    int rc;
+    unsigned short xmodem_crc;
+    unsigned int ack;
+    unsigned short protrom_len = sizeof(send_protroms[n]);
+    size_t total_len = sizeof(ack) + 1 + sizeof(protrom_len) + protrom_len + sizeof(xmodem_crc);
+    unsigned char *buf;
+
+    buf = calloc(1, total_len);
+    if (buf == NULL)
+        return -1;
+
+    ack = SERIAL_ACK;
+
+    memcpy(buf, &ack, sizeof(ack));
+    memcpy(buf + sizeof(ack) + 1, &protrom_len, sizeof(protrom_len));
+    memcpy(buf + sizeof(ack) + 1 + sizeof(protrom_len), send_protroms[n], protrom_len);
+
+    /* Calculate and copy CRC */
+    xmodem_crc = crc_xmodem(buf, total_len - 2);
+    memcpy(buf + sizeof(ack) + 1 + sizeof(protrom_len) + protrom_len, &xmodem_crc, sizeof(xmodem_crc));
+
+    rc = write(fd, buf, total_len);
+
+    free(buf);
+
+    return rc < 0 ? -1 : 0;
+}
+
+int m5730_connect_ccpu(struct ipc_client *client, int serial_fd)
+{
+    int i;
+    int rc;
+
+    usleep(50000);
+
+    /* Send R to quit z-protocol */
+    rc = write(serial_fd, "R", 1);
+    if (rc != 1) {
+        ipc_client_log(client, "Failed to send R to quit z-protocol");
+        return -1;
+    }
+    ipc_client_log(client, "Sent R to quit z-protocol");
+
+    /* Receive/send protrom */
+    for (i = 0; i < 4; i++) {
+        rc = m5730_receive_protrom(serial_fd);
+        if (rc) {
+            ipc_client_log(client, "Failed to receive protrom, %d", rc);
+            return -1;
+        }
+
+        rc = m5730_send_protrom(serial_fd, i);
+        if (rc < 0) {
+            ipc_client_log(client, "Failed to send protrom #%d", i);
+            return -1;
+        }
+
+        usleep(50000);
+        ipc_client_log(client, "Sent protrom #%d", i);
+    }
+
+    return 0;
+}
+
+int ste_load_modem_serial_part(int serial_fd, struct crespo_modem_data_header header, int modem_fd)
+{
+    int rc;
+    unsigned short xmodem_crc;
+    unsigned char *buf;
+
+    buf = malloc(sizeof(header) + header.len - 1 + sizeof(xmodem_crc));
+    if (buf == NULL)
+        return -1;
+
+    memcpy(buf, &header, sizeof(header));
+    rc = read(modem_fd, buf + sizeof(header), header.len - 1);
+    if (rc != header.len - 1)
+        goto error;
+
+    xmodem_crc = crc_xmodem(buf, sizeof(header) + header.len - 1);
+    memcpy(buf + sizeof(header) + header.len - 1, &xmodem_crc, sizeof(xmodem_crc));
+
+    rc = write(serial_fd, buf, sizeof(header) + header.len - 1 + sizeof(xmodem_crc));
+    if (rc < 0)
+        goto error;
+
+    free(buf);
+    return 0;
+
+error:
+    if (buf != NULL)
+        free(buf);
+    return -1;
+}
+
+int ste_load_modem_serial(struct ipc_client *client, int serial_fd)
+{
+    struct crespo_modem_data_header header;
+    int modem_fd;
+    int rc;
+
+    /* Always use alternate image device for STE modems */
+    modem_fd = open(CRESPO_ALT_MODEM_IMAGE_DEVICE, O_RDONLY);
+    if (modem_fd < 0) {
+        ipc_client_log(client, "Failed to open %s", CRESPO_ALT_MODEM_IMAGE_DEVICE);
+        return -1;
+    }
+
+    /* First 12 bytes are a header we don't know what means, but is constant throughout modems */
+    lseek(modem_fd, 12, SEEK_SET);
+
+    header.serial_ack = SERIAL_ACK;
+    header.padding = 0;
+    header.len = 871;
+    header.type = 1;
+
+    rc = ste_load_modem_serial_part(serial_fd, header, modem_fd);
+    if (rc < 0) {
+        ipc_client_log(client, "Failed to send modem.bin part 1 to serial");
+        goto error;
+    }
+
+    usleep(100000);
+
+    rc = m5730_receive_protrom(serial_fd);
+    if (rc) {
+        ipc_client_log(client, "Failed to receive ack for modem.bin part 1");
+        goto error;
+    }
+
+    /* Part 2 - 2 bytes padding */
+    lseek(modem_fd, 2, SEEK_CUR);
+
+    /* Another unknown 12 byte header */
+    lseek(modem_fd, 12, SEEK_CUR);
+
+    header.len = 10653;
+    header.type = 3;
+
+    rc = ste_load_modem_serial_part(serial_fd, header, modem_fd);
+    if (rc < 0) {
+        ipc_client_log(client, "Failed to send modem.bin part 2 to serial");
+        goto error;
+    }
+
+    usleep(100000);
+
+    /* Check response */
+    rc = m5730_receive_protrom(serial_fd);
+    if (rc < 0) {
+        ipc_client_log(client, "Failed to receive ack for modem.bin part 2");
+        goto error;
+    }
+
+    close(modem_fd);
+    return 0;
+
+error:
+    if (modem_fd >= 0)
+        close(modem_fd);
+
+    return -1;
+}
+
+int crespo_ste_configure_serial(int serial_fd, speed_t baud_rate)
+{
+    int ret, ctrl;
+    struct termios termios;
+    ret = ioctl(serial_fd, TCGETS, &termios);
+    if (ret < 0)
+        return -1;
+
+    termios.c_cflag = CS8 | CREAD | CLOCAL | baud_rate;
+    termios.c_iflag = IGNBRK;
+    termios.c_oflag = NL0;
+    termios.c_lflag = 0x0;
+    termios.c_cc[VMIN] = 0x1;
+    termios.c_cc[VTIME] = 0x1;
+
+    ret = ioctl(serial_fd, TCSETS, &termios);
+    if (ret < 0)
+        return -1;
+
+    ret = ioctl(serial_fd, TIOCMGET, &ctrl);
+    if (ret < 0)
+        return -1;
+
+    ctrl = TIOCM_DTR | TIOCM_RTS | TIOCM_CAR | TIOCM_DSR;
+    ret = ioctl(serial_fd, TIOCMSET, &ctrl);
+    if (ret)
+        return -1;
+
+    return 0;
+}
+
+int crespo_ste_boot(struct ipc_client *client)
+{
+
+    int modem_ctl_fd = -1;
+    int serial_fd = -1;
+    int rc;
+
+    if (client == NULL)
+        return -1;
+
+    ipc_client_log(client, "Starting crespo modem boot");
+
+    modem_ctl_fd = open(CRESPO_MODEM_CTL_DEVICE, O_RDWR | O_NDELAY);
+    if (modem_ctl_fd < 0) {
+        ipc_client_log(client, "Opening modem ctl failed");
+        goto error;
+    }
+    ipc_client_log(client, "Opened modem ctl");
+
+    /* Initialize serial */
+    serial_fd = open(CRESPO_MODEM_SERIAL_DEVICE, O_RDWR);
+    if (serial_fd < 0 && errno == ENOENT)
+        serial_fd = open(CRESPO_ALT_MODEM_SERIAL_DEVICE, O_RDWR);
+
+    if (serial_fd < 0) {
+        ipc_client_log(client, "Failed to open serial device");
+        rc = -1;
+        goto error;
+    }
+
+    /* Configure serial */
+    rc = crespo_ste_configure_serial(serial_fd, B9600);
+    if (rc < 0) {
+        ipc_client_log(client, "Failed to configure serial");
+        goto error;
+    }
+
+    rc = ioctl(modem_ctl_fd, IOCTL_MODEM_OFF);
+    if (rc < 0) {
+        ipc_client_log(client, "Powering off modem failed");
+        goto error;
+    }
+    ipc_client_log(client, "Powered off modem");
+
+    rc = ioctl(modem_ctl_fd, IOCTL_MODEM_RESET);
+    if (rc < 0) {
+        ipc_client_log(client, "Resetting modem failed");
+        goto error;
+    }
+    ipc_client_log(client, "Reset modem");
+
+    /* Tell modem to switch to 115200 baud */
+    rc = m5730_write_baud_change(client, serial_fd);
+    if (rc < 0) {
+        ipc_client_log(client, "Failed to change baud rate");
+        goto error;
+    }
+
+    /* Close and re-open serial, setting to 115200 baud */
+    close(serial_fd);
+    serial_fd = open(CRESPO_MODEM_SERIAL_DEVICE, O_RDWR);
+    if (serial_fd < 0 && errno == ENOENT)
+        serial_fd = open(CRESPO_ALT_MODEM_SERIAL_DEVICE, O_RDWR);
+
+    if (serial_fd < 0) {
+        ipc_client_log(client, "Failed to open serial device");
+        goto error;
+    }
+
+    rc = crespo_ste_configure_serial(serial_fd, B115200);
+    if (rc < 0) {
+        ipc_client_log(client, "Failed to configure serial");
+        goto error;
+    }
+
+    /* Connect to M5730 */
+    rc = m5730_connect_ccpu(client, serial_fd);
+    if (rc < 0) {
+        ipc_client_log(client, "Failed to connect to CCPU, error %d", serial_fd);
+        goto error;
+    }
+
+    /* Load modem.bin part to serial */
+    rc = ste_load_modem_serial(client, serial_fd);
+    if (rc) {
+        ipc_client_log(client, "Failed to load modem.bin to serial");
+        goto error;
+    }
+
+    rc = 0;
+    goto complete;
+
+error:
+    /* Flush serial */
+    if (serial_fd >= 0) {
+        rc = ioctl(serial_fd, TCFLSH, TCIOFLUSH);
+        if (rc != 0) {
+            ipc_client_log(client, "Failed to flush serial, error %d", rc);
+        }
+        close(serial_fd);
+    }
+
+    rc = -1;
+
+complete:
+    if (serial_fd >= 0)
+        close(serial_fd);
+
+    if (modem_ctl_fd >= 0)
+        close(modem_ctl_fd);
+
+    return rc;
+}
+
+int crespo_ste_power_on(void *data)
+{
+    void *modem_image_data = NULL;
+    unsigned char *p;
+    size_t wc = 0;
+    int fd = -1;
+    int rc = -1;
+
+    /* Always use alternate image device for STE modems */
+    modem_image_data = file_data_read(CRESPO_ALT_MODEM_IMAGE_DEVICE, CRESPO_STE_MODEM_IMAGE_SIZE, 0x1000, 0);
+    if (modem_image_data == NULL)
+        goto error;
+
+    fd = open(CRESPO_MODEM_CTL_DEVICE, O_RDWR);
+    if (fd < 0)
+        goto error;
+
+    rc = ioctl(fd, IOCTL_MODEM_WAIT_FOR_SBL);
+    if (rc < 0)
+        goto error;
+
+    p = (unsigned char *) modem_image_data;
+
+    p += CRESPO_PSI_SIZE;
+
+    lseek(fd, 0, SEEK_SET);
+
+    while (wc < CRESPO_STE_MODEM_IMAGE_SIZE - CRESPO_PSI_SIZE) {
+        rc = write(fd, (void *) p, CRESPO_STE_MODEM_IMAGE_SIZE - CRESPO_PSI_SIZE - wc);
+        if (rc <= 0)
+            goto error;
+
+        p += rc;
+        wc += rc;
+    }
+
+    rc = ioctl(fd, IOCTL_MODEM_BINARY_LOAD);
+    if (rc < 0)
+        goto error;
+
+    rc = 0;
+
+error:
+    if (modem_image_data != NULL)
+        free(modem_image_data);
+
+    if (fd >= 0)
+        close(fd);
+
+    return rc;
+}
+
+// vim:ts=4:sw=4:expandtab
diff --git a/samsung-ipc/devices/crespo/ste_m5730.h b/samsung-ipc/devices/crespo/ste_m5730.h
new file mode 100644
index 0000000..c6e41de
--- /dev/null
+++ b/samsung-ipc/devices/crespo/ste_m5730.h
@@ -0,0 +1,36 @@
+/*
+ * This file is part of libsamsung-ipc.
+ *
+ * Copyright (C) 2011-2014 Paul Kocialkowski <contact@paulk.fr>
+ *
+ * libsamsung-ipc is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libsamsung-ipc is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with libsamsung-ipc.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+int crespo_is_ste(void);
+int crespo_ste_boot(struct ipc_client *client);
+int crespo_ste_power_on(void *data);
+
+#define CRESPO_MODEM_TYPE_SYSFS        "/sys/class/misc/modem_ctl/type"
+
+/* This is prepended to each message sent via serial */
+#define SERIAL_ACK 4008639402U
+
+struct crespo_modem_data_header {
+    unsigned int serial_ack;
+    char padding;
+    unsigned short len;
+    char type;
+} __attribute__((__packed__));
+
+
diff --git a/samsung-ipc/ipc_devices.c b/samsung-ipc/ipc_devices.c
index ad7d23c..f0d4461 100644
--- a/samsung-ipc/ipc_devices.c
+++ b/samsung-ipc/ipc_devices.c
@@ -44,6 +44,16 @@ struct ipc_device_desc ipc_devices[] = {
         .nv_data_specs = &crespo_nv_data_specs,
     },
     {
+        .name = "crespo",
+        .board_name = "Samsung S5PC110/S5PV210-based board",
+        .kernel_version = NULL,
+        .fmt_ops = &crespo_fmt_ops,
+        .rfs_ops = &crespo_rfs_ops,
+        .handlers = &crespo_handlers,
+        .gprs_specs = &crespo_gprs_specs,
+        .nv_data_specs = &crespo_nv_data_specs,
+    },
+    {
         .name = "aries",
         .board_name = "aries",
         .kernel_version = NULL,
-- 
2.11.0


From f0283623b695a9d7febd5205b10729b4bf6e1f54 Mon Sep 17 00:00:00 2001
From: Jonathan Bakker <xc-racer2@live.ca>
Date: Mon, 31 Dec 2018 12:36:17 -0800
Subject: [PATCH 2/3] ipc-modem: Add support for RFS commands

Some devices may need access to RFS commands before they connect
---
 Android.mk        |   4 +-
 tools/Makefile.am |   4 +-
 tools/ipc-modem.c | 103 ++++++++-
 tools/rfs.c       | 610 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 tools/rfs.h       |   7 +
 5 files changed, 724 insertions(+), 4 deletions(-)
 create mode 100644 tools/rfs.c
 create mode 100644 tools/rfs.h

diff --git a/Android.mk b/Android.mk
index 541c63a..4a52f9a 100644
--- a/Android.mk
+++ b/Android.mk
@@ -101,12 +101,14 @@ include $(BUILD_STATIC_LIBRARY)
 
 include $(CLEAR_VARS)
 
-LOCAL_SRC_FILES := tools/ipc-modem.c
+LOCAL_SRC_FILES := tools/ipc-modem.c \
+	tools/rfs.c
 
 LOCAL_C_INCLUDES := $(LOCAL_PATH)/include
 
 LOCAL_STATIC_LIBRARIES := libsamsung-ipc
 LOCAL_SHARED_LIBRARIES := libutils libcrypto
+LOCAL_LDLIBS := -lpthread
 
 LOCAL_MODULE := ipc-modem
 LOCAL_MODULE_TAGS := optional
diff --git a/tools/Makefile.am b/tools/Makefile.am
index 9336a64..d559be5 100644
--- a/tools/Makefile.am
+++ b/tools/Makefile.am
@@ -10,9 +10,9 @@ bin_PROGRAMS = \
 	nv_data-md5 \
 	$(NULL)
 
-ipc_modem_SOURCES = ipc-modem.c
+ipc_modem_SOURCES = ipc-modem.c rfs.c
 ipc_modem_LDADD = $(top_builddir)/samsung-ipc/libsamsung-ipc.la
-ipc_modem_LDFLAGS =
+ipc_modem_LDFLAGS = -lpthread
 
 ipc_test_SOURCES = ipc-test.c
 ipc_test_LDADD = $(top_builddir)/samsung-ipc/libsamsung-ipc.la
diff --git a/tools/ipc-modem.c b/tools/ipc-modem.c
index 935677b..92fd05f 100644
--- a/tools/ipc-modem.c
+++ b/tools/ipc-modem.c
@@ -23,6 +23,7 @@
 #include <unistd.h>
 #include <stdint.h>
 #include <stdbool.h>
+#include <signal.h>
 #include <termios.h>
 #include <fcntl.h>
 #include <string.h>
@@ -34,6 +35,8 @@
 
 #include <samsung-ipc.h>
 
+#include "rfs.h"
+
 #define MODEM_STATE_LPM     0
 #define MODEM_STATE_NORMAL  2
 #define MODEM_STATE_SIM_OK  4
@@ -340,6 +343,29 @@ void modem_response_net(struct ipc_client *client, struct ipc_message *resp)
     }
 }
 
+void modem_response_handle_rfs(struct ipc_client *client, struct ipc_message *resp)
+{
+    switch(resp->command)
+    {
+        case IPC_RFS_NV_READ_ITEM:
+            ipc_rfs_nv_read_item(client, resp);
+            break;
+        case IPC_RFS_NV_WRITE_ITEM:
+            ipc_rfs_nv_write_item(client, resp);
+            break;
+        case IPC_RFS_GET_FILE_INFO:
+        case IPC_RFS_GET_HANDLE_INFO:
+            ipc_rfs_file_info(client, resp);
+            break;
+        case IPC_RFS_READ_DIR:
+            ipc_rfs_read_dir(client, resp);
+            break;
+        default:
+            ipc_rfs_generic_io(client, resp);
+            break;
+    }
+}
+
 void modem_response_handle(struct ipc_client *client, struct ipc_message *resp)
 {
     switch(IPC_GROUP(resp->command))
@@ -363,6 +389,9 @@ void modem_response_handle(struct ipc_client *client, struct ipc_message *resp)
             if(in_call)
                 modem_snd_no_mic_mute(client);
         break;
+        case IPC_GROUP_RFS:
+            modem_response_handle_rfs(client, resp);
+        break;
     }
 }
 
@@ -397,6 +426,36 @@ int modem_read_loop(struct ipc_client *client)
     return 0;
 }
 
+int modem_rfs_read_loop(struct ipc_client *client)
+{
+    struct ipc_message resp;
+    int rc;
+
+    memset(&resp, 0, sizeof(resp));
+
+    while(1) {
+        usleep(3000);
+
+        rc = ipc_client_poll(client, NULL, NULL);
+        if (rc < 0) {
+            continue;
+        }
+
+        rc = ipc_client_recv(client, &resp);
+        if(rc < 0) {
+            printf("[E] Can't RECV from modem: please run this again\n");
+            break;
+        }
+
+        modem_response_handle(client, &resp);
+
+        if(resp.data != NULL)
+            free(resp.data);
+    }
+
+    return 0;
+}
+
 void modem_log_handler(void *user_data, const char *msg)
 {
     int i, l;
@@ -456,6 +515,42 @@ int modem_stop(struct ipc_client *client)
     return 0;
 }
 
+void *rfs_thread(void *vargp)
+{
+    struct ipc_client *client_rfs;
+    int rc;
+
+    client_rfs = ipc_client_create(IPC_CLIENT_TYPE_RFS);
+
+    if (client_rfs == 0) {
+        printf("[E] Could not create IPC client; aborting ...\n");
+        return NULL;
+    }
+
+    rc = ipc_client_data_create(client_rfs);
+    if (rc) {
+        printf("[E] Failed to create RFS client data; aborting ... \n");
+        goto err_data_create;
+    }
+
+    ipc_client_log_callback_register(client_rfs, modem_log_handler, NULL);
+
+    rc = ipc_client_open(client_rfs);
+    if (rc) {
+        printf("[E] Failed to open RFS client; aborting ... \n");
+        goto err_data_create;
+    }
+
+    printf("[1] Starting modem_read_loop on RFS client\n");
+    modem_read_loop(client_rfs);
+
+    ipc_client_close(client_rfs);
+err_data_create:
+    ipc_client_destroy(client_rfs);
+
+    return NULL;
+}
+
 void print_help()
 {
     printf("usage: ipc-modem <command>\n");
@@ -476,6 +571,7 @@ int main(int argc, char *argv[])
     int opt_i = 0;
     int rc = -1;
     int debug = 0;
+    pthread_t thread_rfs;
 
     struct option opt_l[] = {
         {"help",    no_argument,        0,  0 },
@@ -545,15 +641,20 @@ int main(int argc, char *argv[])
             printf("[0] Starting modem on FMT client\n");
             rc = modem_start(client_fmt);
             if(rc < 0) {
-                printf("[E] Something went wrong\n");
+                printf("[E] Something went wrong with FMT client\n");
                 modem_stop(client_fmt);
                 return 1;
             }
 
+            pthread_create(&thread_rfs, NULL, rfs_thread, NULL);
+
             printf("[1] Starting modem_read_loop on FMT client\n");
             modem_read_loop(client_fmt);
 
             modem_stop(client_fmt);
+
+            pthread_kill(thread_rfs, 9);
+            pthread_join(thread_rfs, NULL);
         } else {
             printf("[E] Unknown argument: '%s'\n", argv[optind]);
             print_help();
diff --git a/tools/rfs.c b/tools/rfs.c
new file mode 100644
index 0000000..2a94808
--- /dev/null
+++ b/tools/rfs.c
@@ -0,0 +1,610 @@
+/*
+ * This file is part of Samsung-RIL.
+ *
+ * Copyright (C) 2011-2014 Paul Kocialkowski <contact@paulk.fr>
+ *
+ * Samsung-RIL is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Samsung-RIL is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Samsung-RIL.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <dirent.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <string.h>
+#include <limits.h>     /* PATH_MAX */
+
+#include <errno.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include "rfs.h"
+
+int ipc_rfs_nv_read_item(struct ipc_client *client, struct ipc_message *message)
+{
+	struct ipc_rfs_nv_read_item_response_header response_header;
+	struct ipc_rfs_nv_read_item_request_data *data;
+	struct ipc_rfs_data *ipc_rfs_data;
+	void *response_data = NULL;
+	size_t response_size = 0;
+	void *nv_data = NULL;
+	int rc;
+
+	if (message == NULL || message->data == NULL || message->size < sizeof(struct ipc_rfs_nv_read_item_request_data))
+		return -1;
+
+	data = (struct ipc_rfs_nv_read_item_request_data *) message->data;
+
+	memset(&response_header, 0, sizeof(response_header));
+
+	nv_data = ipc_nv_data_read(client, data->length, data->offset);
+	if (nv_data == NULL) {
+		printf("Reading %d nv_data bytes at offset 0x%x failed", data->length, data->offset);
+
+		response_header.confirm = 0;
+
+		rc = ipc_client_send(client, message->aseq, IPC_RFS_NV_READ_ITEM, IPC_TYPE_RESP, (void *) &response_header, sizeof(response_header));
+		if (rc < 0)
+			goto complete;
+
+		goto complete;
+	}
+
+	printf("Read %d nv_data bytes at offset 0x%x", data->length, data->offset);
+
+	response_header.confirm = 1;
+	response_header.offset = data->offset;
+	response_header.length = data->length;
+
+	response_size = ipc_rfs_nv_data_item_size_setup(&response_header, nv_data, data->length);
+	if (response_size == 0)
+		goto complete;
+
+	response_data = ipc_rfs_nv_read_item_setup(&response_header, nv_data, data->length);
+	if (response_data == NULL)
+		goto complete;
+
+	rc = ipc_client_send(client, message->aseq, IPC_RFS_NV_READ_ITEM, IPC_TYPE_RESP, response_data, response_size);
+	if (rc < 0)
+		goto complete;
+
+	goto complete;
+
+complete:
+	if (response_data != NULL && response_size > 0)
+		free(response_data);
+
+	if (nv_data != NULL)
+		free(nv_data);
+
+	return 0;
+}
+
+int ipc_rfs_nv_write_item(struct ipc_client *client, struct ipc_message *message)
+{
+	struct ipc_rfs_nv_write_item_request_header *header;
+	struct ipc_rfs_nv_write_item_response_data data;
+	struct ipc_rfs_data *ipc_rfs_data;
+	void *nv_data;
+	size_t nv_size;
+	int rc;
+
+	if (message == NULL || message->data == NULL || message->size < sizeof(struct ipc_rfs_nv_write_item_request_header))
+		return -1;
+	header = (struct ipc_rfs_nv_write_item_request_header *) message->data;
+
+	nv_size = ipc_rfs_nv_write_item_size_extract(message->data, message->size);
+	if (nv_size == 0)
+		return 0;
+
+	nv_data = ipc_rfs_nv_write_item_extract(message->data, message->size);
+	if (nv_data == NULL)
+		return 0;
+
+	memset(&data, 0, sizeof(data));
+
+	rc = ipc_nv_data_write(client, nv_data, header->length, header->offset);
+	if (rc < 0) {
+		printf("Writing %d nv_data byte(s) at offset 0x%x failed", header->length, header->offset);
+
+		data.confirm = 0;
+	} else {
+		printf("Wrote %d nv_data byte(s) at offset 0x%x", header->length, header->offset);
+
+		data.confirm = 1;
+		data.offset = header->offset;
+		data.length = header->length;
+	}
+
+	rc = ipc_client_send(client, message->aseq, IPC_RFS_NV_WRITE_ITEM, IPC_TYPE_RESP, (void *) &data, sizeof(data));
+	if (rc < 0)
+		return 0;
+
+	return 0;
+}
+
+int ipc_rfs_read_dir(struct ipc_client *client, struct ipc_message *message)
+{
+	struct ipc_rfs_read_dir_request_header *header;
+	struct ipc_rfs_read_dir_response_header *response_header;
+	struct dirent *dirent;
+	DIR *dirp;
+	void *buffer = NULL;
+	size_t len;
+	int rc;
+
+	if (message == NULL || message->data == NULL || message->size < sizeof(struct ipc_rfs_read_dir_request_header))
+		return -1;
+
+	header = (struct ipc_rfs_read_dir_request_header *) message->data;
+
+	dirp = (DIR *) header->addr;
+
+	dirent = readdir(dirp);
+	if (dirent == NULL) {
+		len = sizeof(struct ipc_rfs_read_dir_response_header);
+		buffer = alloca(len);
+		if (buffer == NULL)
+			return -1;
+		response_header = (struct ipc_rfs_read_dir_response_header *) buffer;
+		response_header->ret = -1;
+		response_header->err = errno;
+	} else {
+		len = sizeof(struct ipc_rfs_read_dir_response_header) + strlen(dirent->d_name);
+		buffer = alloca(len);
+		if (buffer == NULL)
+			return -1;
+		response_header = (struct ipc_rfs_read_dir_response_header *) buffer;
+		response_header->len = strlen(dirent->d_name);
+		strcpy((char *) buffer + sizeof(struct ipc_rfs_read_dir_response_header), dirent->d_name);
+	}
+
+	rc = ipc_client_send(client, message->aseq, IPC_RFS_READ_DIR, IPC_TYPE_RESP, buffer, len);
+
+	return 0;
+}
+
+int mkdir_p(const char *path, size_t len)
+{
+    /* Adapted from http://stackoverflow.com/a/2336245/119527 */
+    char _path[PATH_MAX];
+    char *p;
+
+    errno = 0;
+
+    /* Copy string so its mutable */
+    if (len > sizeof(_path)-1) {
+        errno = ENAMETOOLONG;
+        return -1;
+    }
+    strncpy(_path, path, len);
+
+    /* Iterate the string */
+    for (p = _path + 1; *p; p++) {
+        if (*p == '/') {
+            /* Temporarily truncate */
+            *p = '\0';
+
+            if (mkdir(_path, S_IRWXU) != 0) {
+                if (errno != EEXIST)
+                    return -1;
+            }
+
+            *p = '/';
+        }
+    }
+
+    if (mkdir(_path, S_IRWXU) != 0) {
+        if (errno != EEXIST)
+            return -1;
+    }
+
+    return 0;
+}
+
+int ipc_rfs_make_path(struct ipc_client *client, char *path, char *rel_path, int rel_path_len)
+{
+	int rel_path_pos = 0;
+	char *p;
+	char *efs_root;
+
+	if (rel_path == NULL) {
+		printf("rel_path is null");
+		return -1;
+	}
+
+	efs_root = ipc_client_efs_root(client);
+	if (efs_root == NULL) {
+		printf("Failed to read efs_root");
+		return -1;
+	}
+
+	/* Combine efs_root and rel_path */
+	strcpy(path, efs_root);
+	strncat(path, rel_path, rel_path_len);
+
+	/* See how many subdirectories we start in */
+	p = efs_root;
+	while (strstr(p, "/") != NULL) {
+		p += 1;
+		rel_path_pos--;
+	}
+
+	/* Count number of times we go up a directory */
+	p = path;
+	while (strstr(p, "/../") != NULL) {
+		p += 4;
+		rel_path_pos--;
+	}
+
+	/* Count number of directory separators */
+	p = path;
+	while (strstr(p, "/") != NULL) {
+		p += 1;
+		rel_path_pos++;
+	}
+
+	/* Count number of doubled directory separators */
+	p = path;
+	while (strstr(p, "//") != NULL) {
+		p += 1;
+		rel_path_pos--;
+	}
+
+	/* Make sure we're not trying to go above efs_root */
+	if (rel_path_pos < 0) {
+		printf("WARNING: RIL is trying to access files outside of /efs/, denying access");
+		return -1;
+	}
+
+	printf("Created path %s", path);
+
+	return 0;
+}
+
+int ipc_rfs_generic_io(struct ipc_client *client, struct ipc_message *message)
+{
+	struct ipc_rfs_generic_io_response_header data;
+	struct ipc_rfs_data *ipc_rfs_data;
+	int rc;
+
+	if (message == NULL || message->data == NULL)
+		return -1;
+
+	memset(&data, 0, sizeof(data));
+
+	switch (message->command) {
+		case IPC_RFS_READ_FILE:
+		{
+			if (message->size < sizeof(struct ipc_rfs_read_file_request_header))
+				return -1;
+
+			struct ipc_rfs_read_file_request_header *header =
+					(struct ipc_rfs_read_file_request_header *) message->data;
+			struct ipc_rfs_generic_io_response_header *response;
+
+			/* Special case - we need a bigger buffer */
+			void *buf = alloca(sizeof(struct ipc_rfs_generic_io_response_header) + header->len);
+			if (buf == NULL) {
+				printf("alloca failed");
+				goto error;
+			}
+
+			rc = read(header->fd,
+					(char *) ((char *) buf + sizeof(struct ipc_rfs_generic_io_response_header)),
+					header->len);
+
+			response = buf;
+
+			response->ret = rc;
+
+			if (response->ret == 0)
+				response->err = ENOENT;
+			else if (response->ret < 0)
+				response->err = errno;
+			else
+				response->err = 0;
+
+			rc = ipc_client_send(client, message->aseq, message->command, IPC_TYPE_RESP, response,
+					sizeof(struct ipc_rfs_generic_io_response_header) + response->ret);
+
+			return 0;
+		}
+		case IPC_RFS_WRITE_FILE:
+		{
+			if (message->size < sizeof(struct ipc_rfs_write_file_request_header))
+				return -1;
+
+			struct ipc_rfs_write_file_request_header *header =
+					(struct ipc_rfs_write_file_request_header *) message->data;
+
+			data.ret = write(header->fd,
+					header + sizeof(struct ipc_rfs_write_file_request_header),
+					header->len);
+			break;
+		}
+		case IPC_RFS_LSEEK_FILE:
+		{
+			if (message->size < sizeof(struct ipc_rfs_lseek_file_request_header))
+				return -1;
+
+			struct ipc_rfs_lseek_file_request_header *header =
+					(struct ipc_rfs_lseek_file_request_header *) message->data;
+			data.ret = lseek(header->fd, header->offset, header->whence);
+			break;
+		}
+		case IPC_RFS_CLOSE_FILE:
+		{
+			if (message->size < sizeof(struct ipc_rfs_close_file_request_header))
+				return -1;
+
+			struct ipc_rfs_close_file_request_header *header =
+					(struct ipc_rfs_close_file_request_header *) message->data;
+			data.ret = close(header->fd);
+			break;
+		}
+		case IPC_RFS_RENAME_FILE:
+		{
+			if (message->size < sizeof(struct ipc_rfs_rename_file_request_header))
+				return -1;
+
+			struct ipc_rfs_rename_file_request_header *header1 =
+					(struct ipc_rfs_rename_file_request_header *) message->data;
+			struct ipc_rfs_rename_file_request_header *header2 =
+					(struct ipc_rfs_rename_file_request_header *)
+					((char *) message->data
+					+ sizeof(struct ipc_rfs_rename_file_request_header)
+					+ header1->path_len);
+			char oldpath[PATH_MAX];
+			char newpath[PATH_MAX];;
+
+			rc = ipc_rfs_make_path(client, oldpath,
+					(char *) header1 + sizeof(struct ipc_rfs_rename_file_request_header),
+					header1->path_len);
+
+			if (rc < 0) {
+				printf("ipc_rfs_make_path failed");
+				goto error;
+			}
+
+			rc = ipc_rfs_make_path(client, newpath,
+					(char *) header2 + sizeof(struct ipc_rfs_rename_file_request_header),
+					header2->path_len);
+
+			if (rc < 0) {
+				printf("ipc_rfs_make_path failed");
+				goto error;
+			}
+
+			data.ret = rename(oldpath, newpath);
+			break;
+		}
+		case IPC_RFS_UNLINK_FILE:
+		{
+			if (message->size < sizeof(struct ipc_rfs_unlink_file_request_header))
+				return -1;
+
+			struct ipc_rfs_unlink_file_request_header *header =
+					(struct ipc_rfs_unlink_file_request_header *) message->data;
+			char path[PATH_MAX];
+			rc = ipc_rfs_make_path(client, path,
+					(char *) message->data + sizeof(struct ipc_rfs_unlink_file_request_header),
+					header->path_len);
+			if (rc < 0)
+				goto error;
+			rc = unlink(path);
+			if (rc < 0 && errno == ENOENT)
+				rc = 0;
+			data.ret = rc;
+
+			break;
+		}
+		case IPC_RFS_MAKE_DIR:
+		{
+			if (message->size < sizeof(struct ipc_rfs_make_dir_request_header))
+				return -1;
+
+			struct stat buf;
+			struct ipc_rfs_make_dir_request_header *header =
+					(struct ipc_rfs_make_dir_request_header *) message->data;
+			char path[PATH_MAX];
+			rc = ipc_rfs_make_path(client, path,
+					(char *) message->data + sizeof(struct ipc_rfs_make_dir_request_header),
+					header->path_len);
+			if (rc < 0)
+				goto error;
+			rc = stat(path, &buf);
+			if (rc < 0 && errno == ENOENT)
+				rc = mkdir(path, 0660);
+			data.ret = rc;
+			break;
+		}
+		case IPC_RFS_REMOVE_DIR:
+		{
+			if (message->size < sizeof(struct ipc_rfs_remove_dir_request_header))
+				return -1;
+
+			struct ipc_rfs_remove_dir_request_header *header =
+					(struct ipc_rfs_remove_dir_request_header *) message->data;
+			char path[PATH_MAX];
+			rc = ipc_rfs_make_path(client, path,
+					(char *) message->data + sizeof(struct ipc_rfs_remove_dir_request_header),
+					header->path_len);
+			if (rc < 0)
+				goto error;
+			data.ret = rmdir(path);
+			break;
+		}
+		case IPC_RFS_OPEN_DIR:
+		{
+			if (message->size < sizeof(struct ipc_rfs_open_dir_request_header))
+				return -1;
+
+			DIR *dirp;
+			struct ipc_rfs_open_dir_request_header *header =
+					(struct ipc_rfs_open_dir_request_header *) message->data;
+			char path[PATH_MAX];
+			rc = ipc_rfs_make_path(client, path,
+					(char *) message->data + sizeof(struct ipc_rfs_open_dir_request_header),
+					header->path_len);
+			if (rc < 0)
+				goto error;
+			dirp = opendir(path);
+			if (dirp)
+				data.ret = (int) dirp;
+			else
+				data.ret = -1;
+			break;
+		}
+		case IPC_RFS_CLOSE_DIR:
+		{
+			if (message->size < sizeof(struct ipc_rfs_close_dir_request_header))
+				return -1;
+
+			struct ipc_rfs_close_dir_request_header *header =
+					(struct ipc_rfs_close_dir_request_header *) message->data;
+			data.ret = closedir((DIR *) header->addr);
+			break;
+		}
+		case IPC_RFS_OPEN_FILE:
+		{
+			if (message->size < sizeof(struct ipc_rfs_open_file_request_header))
+				return -1;
+
+			struct ipc_rfs_open_file_request_header *header =
+					(struct ipc_rfs_open_file_request_header *) message->data;
+			char path[PATH_MAX];
+			rc = ipc_rfs_make_path(client, path,
+					(char *) message->data + sizeof(struct ipc_rfs_open_file_request_header),
+					header->path_len);
+			if (rc < 0)
+				goto error;
+			if (header->flags & O_CREAT) {
+				printf("Recursively creating directory and files");
+
+				char *index = strrchr(path, '/');
+				if (index != NULL)
+					mkdir_p(path, index - path);
+			}
+			data.ret = open(path, header->flags | O_DSYNC, 0644);
+			break;
+		}
+		default:
+		{
+			printf("Unknown generic IO command %d", message->command);
+			goto error;
+		}
+	}
+
+	if (data.ret < 0)
+		data.err = errno;
+
+	rc = ipc_client_send(client, message->aseq, message->command, IPC_TYPE_RESP, &data,
+			sizeof(struct ipc_rfs_generic_io_response_header));
+
+	return 0;
+
+error:
+	data.ret = -1;
+	data.err = EPERM;
+
+	rc = ipc_client_send(client, message->aseq, message->command, IPC_TYPE_RESP, &data,
+			sizeof(struct ipc_rfs_generic_io_response_header));
+
+	return 0;
+}
+
+int ipc_rfs_file_info(struct ipc_client *client, struct ipc_message *message)
+{
+	struct ipc_rfs_data *ipc_rfs_data;
+	struct ipc_rfs_file_info_response_data data;
+	struct stat buf;
+	struct tm result;
+	char path[PATH_MAX];
+	int rc;
+
+	if (message == NULL || message->data == NULL)
+		return -1;
+
+	memset(&data, 0, sizeof(data));
+
+	if (message->command == IPC_RFS_GET_FILE_INFO) {
+		if (message->size < sizeof(struct ipc_rfs_get_file_info_request_header))
+			return -1;
+
+		struct ipc_rfs_get_file_info_request_header *header =
+				(struct ipc_rfs_get_file_info_request_header *) message->data;
+
+		rc = ipc_rfs_make_path(client, path,
+				(char*) message->data + sizeof(struct ipc_rfs_get_file_info_request_header),
+				header->path_len);
+		if (rc < 0) {
+			data.ret = -1;
+			data.err = EPERM;
+			goto out;
+		}
+
+		rc = stat(path, &buf);
+	} else if (message->command == IPC_RFS_GET_HANDLE_INFO) {
+		if (message->size < sizeof(struct ipc_rfs_get_handle_info_request_header))
+			return -1;
+
+		struct ipc_rfs_get_handle_info_request_header *header =
+				(struct ipc_rfs_get_handle_info_request_header *) message->data;
+
+		rc = fstat(header->fd, &buf);
+	} else {
+		printf("Unknown command %d for %s", message->command, __func__);
+		return -1;
+	}
+
+	if (rc < 0) {
+		data.ret = rc;
+		data.err = errno;
+	} else {
+		if (S_ISDIR(buf.st_mode)) {
+			data.type = IPC_RFS_TYPE_DIRECTORY;
+		} else if (S_ISREG(buf.st_mode)) {
+			data.type = IPC_RFS_TYPE_FILE;
+		} else {
+			printf("Unknown file type, setting to 0");
+			data.type = IPC_RFS_TYPE_UNKNOWN;
+		}
+		data.size = buf.st_size;
+
+		// Store creation times
+		localtime_r((time_t *) &buf.st_ctime, &result);
+		data.c_year = (unsigned char) (result.tm_year  - 100);
+		data.c_month = (unsigned char) (result.tm_mon + 1);
+		data.c_day = (unsigned char) result.tm_mday;
+		data.c_hour = (unsigned char) result.tm_hour;
+		data.c_min = (unsigned char) result.tm_min;
+		data.c_sec = (unsigned char) result.tm_sec;
+
+		// Store modification times
+		localtime_r((time_t *) &buf.st_mtime, &result);
+		data.m_year = (unsigned char) (result.tm_year  - 100);
+		data.m_month = (unsigned char) (result.tm_mon + 1);
+		data.m_day = (unsigned char) result.tm_mday;
+		data.m_hour = (unsigned char) result.tm_hour;
+		data.m_min = (unsigned char) result.tm_min;
+		data.m_sec = (unsigned char) result.tm_sec;
+	}
+
+out:
+	rc = ipc_client_send(client, message->aseq, message->command, IPC_TYPE_RESP, (void *) &data, sizeof(data));
+
+	return 0;
+}
diff --git a/tools/rfs.h b/tools/rfs.h
new file mode 100644
index 0000000..6957ffa
--- /dev/null
+++ b/tools/rfs.h
@@ -0,0 +1,7 @@
+#include <samsung-ipc.h>
+
+int ipc_rfs_nv_read_item(struct ipc_client *client, struct ipc_message *message);
+int ipc_rfs_nv_write_item(struct ipc_client *client, struct ipc_message *message);
+int ipc_rfs_file_info(struct ipc_client *client, struct ipc_message *message);
+int ipc_rfs_generic_io(struct ipc_client *client, struct ipc_message *message);
+int ipc_rfs_read_dir(struct ipc_client *client, struct ipc_message *message);
-- 
2.11.0


From 195a471be277401d94339885ed5bb7e51e232b71 Mon Sep 17 00:00:00 2001
From: Jonathan Bakker <xc-racer2@live.ca>
Date: Thu, 3 Jan 2019 18:04:28 -0800
Subject: [PATCH 3/3] Make /proc/cpuinfo matching actually work

strncmp returns 0 for a match, plus we shouldn't be trying to compare
the null characters at the end of the string.  Also, don't bother
converting to lower case; there's no point
---
 samsung-ipc/ipc.c | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/samsung-ipc/ipc.c b/samsung-ipc/ipc.c
index fcfd19c..d4daa38 100644
--- a/samsung-ipc/ipc.c
+++ b/samsung-ipc/ipc.c
@@ -75,14 +75,12 @@ int ipc_device_detect(void)
 
     line = strtok(buffer, "\n");
     while (line != NULL) {
-        if (strncmp(line, "Hardware", 9) == 9) {
+        if (strncmp(line, "Hardware", 8) == 0) {
             p = line + 11;
             c = p;
 
-            while (*c != '\n' && *c != '\0') {
-                *c = tolower(*c);
+            while (*c != '\n' && *c != '\0')
                 c++;
-            }
 
             *c = '\0';
 
-- 
2.11.0

